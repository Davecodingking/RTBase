### Photon Mapping 实现详解（基于《RenderingAlgorithms.pdf》页面 118-177）

---

#### **1. Photon Mapping 核心概念（页面 118-120）**
Photon Mapping 是两步法全局光照算法：
1. **光子发射与存储**：从光源发射光子，追踪其与场景的交互，并在漫反射表面存储光子。
2. **密度估计**：从相机出发，利用存储的光子图估算间接光照。

光子分类存储：
- **全局光子图**：经过任意次反射后存储在漫反射表面的光子。
- **焦散光子图**：经过至少一次镜面反射后存储在漫反射表面的光子。
- **体积光子图**：参与介质中的光子。

---

#### **2. 光子发射与追踪（页面 121-124）**
**代码示例：光子结构定义与发射逻辑**
```cpp
struct Photon {
    vec3 position;    // 光子位置
    vec3 direction;   // 入射方向
    vec3 power;       // 光子能量（RGB）
    bool isDiffuse;   // 是否为漫反射交互
};

// 从光源发射光子
void emitPhotons(Light* light, int numPhotons, std::vector<Photon>& globalMap, std::vector<Photon>& causticMap) {
    for (int i = 0; i < numPhotons; i++) {
        // 采样光源位置和方向
        float pdfPos, pdfDir;
        vec3 pos = light->samplePosition(pdfPos);
        vec3 dir = light->sampleDirection(pdfDir);
        vec3 throughput = light->getIntensity() / (pdfPos * pdfDir * numPhotons);

        Ray ray(pos, dir);
        tracePhoton(ray, throughput, globalMap, causticMap, 0);
    }
}

// 递归追踪光子
void tracePhoton(Ray ray, vec3 throughput, std::vector<Photon>& globalMap, std::vector<Photon>& causticMap, int depth) {
    HitRecord hit = scene.intersect(ray);
    if (!hit.valid) return;

    // 仅在漫反射表面存储光子
    if (hit.material.isDiffuse()) {
        Photon photon;
        photon.position = hit.position;
        photon.direction = -ray.direction; // 入射方向的反方向
        photon.power = throughput;
        photon.isDiffuse = true;
        globalMap.push_back(photon);
    }

    // 俄罗斯轮盘终止
    float surviveProb = std::min(0.8f, throughput.maxComponent());
    if (random() > surviveProb) return;

    // 采样下一方向（BSDF采样）
    vec3 newDir = hit.material.sampleBSDF(hit.normal, -ray.direction);
    Ray newRay(hit.position, newDir);
    tracePhoton(newRay, throughput * hit.material.evalBSDF(newDir) / surviveProb, globalMap, causticMap, depth + 1);
}
```

---

#### **3. 光子存储与加速结构（页面 126-130）**
使用 **KD-Tree** 加速光子查询：
```cpp
class KDNode {
public:
    Photon photon;
    KDNode* left;
    KDNode* right;
    int axis; // 划分轴（0=x, 1=y, 2=z）
};

class KDTree {
public:
    KDNode* root;
    void build(std::vector<Photon>& photons) {
        // 递归划分光子位置，构建平衡KD-Tree
        // 实现略（类似标准KD-Tree构建算法）
    }

    std::vector<Photon> queryRadius(const vec3& p, float radius) {
        std::vector<Photon> result;
        queryRadiusRecursive(root, p, radius, result);
        return result;
    }

private:
    void queryRadiusRecursive(KDNode* node, const vec3& p, float radius, std::vector<Photon>& result) {
        if (!node) return;
        float dist = (node->photon.position - p).length();
        if (dist <= radius) result.push_back(node->photon);
        // 递归左右子树
        if (p[node->axis] - radius <= node->photon.position[node->axis])
            queryRadiusRecursive(node->left, p, radius, result);
        if (p[node->axis] + radius >= node->photon.position[node->axis])
            queryRadiusRecursive(node->right, p, radius, result);
    }
};

// 全局光子图和焦散光子图分别构建KD-Tree
KDTree globalPhotonTree, causticPhotonTree;
globalPhotonTree.build(globalMap);
causticPhotonTree.build(causticMap);
```

---

#### **4. 密度估计（页面 131-138）**
使用核函数平滑光子密度，计算间接光照：
```cpp
vec3 estimateIndirectLight(vec3 position, vec3 normal, const KDTree& photonTree) {
    float radius = 0.5f; // 动态调整半径
    auto photons = photonTree.queryRadius(position, radius);
    if (photons.empty()) return vec3(0);

    vec3 sum(0);
    for (auto& photon : photons) {
        // 核函数（Epanechnikov 核）
        float dist = (photon.position - position).length();
        float weight = 1.0f - (dist * dist) / (radius * radius);
        weight = std::max(0.0f, weight);

        // 仅考虑法线方向的半球
        if (dot(photon.direction, normal) > 0) {
            vec3 bsdf = hit.material.evalBSDF(photon.direction);
            sum += photon.power * bsdf * weight;
        }
    }

    // 归一化
    float area = M_PI * radius * radius;
    return sum / (area * photons.size());
}
```

---

#### **5. 与路径追踪整合（页面 140-146）**
在路径追踪中结合光子映射：
```cpp
vec3 pathTrace(Ray ray, int depth) {
    if (depth > MAX_DEPTH) return vec3(0);
    HitRecord hit = scene.intersect(ray);
    if (!hit.valid) return environmentLight(ray.direction);

    // 直接光照（传统采样）
    vec3 direct = sampleDirectLight(hit);

    // 间接光照（光子映射）
    vec3 indirect(0);
    if (hit.material.isDiffuse()) {
        indirect += estimateIndirectLight(hit.position, hit.normal, globalPhotonTree);
        indirect += estimateIndirectLight(hit.position, hit.normal, causticPhotonTree);
    }

    // 递归镜面反射
    if (hit.material.isSpecular()) {
        Ray reflected = sampleSpecular(hit);
        return direct + hit.material.albedo * pathTrace(reflected, depth + 1);
    }

    return direct + indirect;
}
```

---

#### **6. 优化与进阶（页面 152-177）**
**最终聚集（Final Gathering）**：
```cpp
vec3 finalGathering(vec3 position, vec3 normal) {
    vec3 sum(0);
    int numSamples = 64;
    for (int i = 0; i < numSamples; i++) {
        vec3 dir = cosineSampleHemisphere(normal);
        Ray ray(position, dir);
        HitRecord secondaryHit = scene.intersect(ray);
        if (secondaryHit.valid && secondaryHit.material.isDiffuse()) {
            // 在次级命中点使用光子映射
            sum += estimateIndirectLight(secondaryHit.position, secondaryHit.normal, globalPhotonTree);
        }
    }
    return sum / numSamples;
}
```

**渐进式光子映射（Progressive Photon Mapping, PPM）**：
- 每轮迭代发射少量光子并逐步缩小核半径。
- 存储每个像素的统计信息（位置、半径、光子数、累计能量）。

---

#### **7. 与用户已实现部分的整合**
- **Radiosity**：Radiosity 适用于低频间接光照，而Photon Mapping擅长高频细节（如焦散）。可结合两者，用Radiosity计算大面积间接光，Photon Mapping补充细节。
- **代码兼容性**：确保光子映射的KD-Tree与场景查询接口兼容，例如 `scene.intersect(ray)` 需支持快速光线追踪。

---

#### **测试场景与报告对比**
- **测试场景**：Cornell Box 中包含玻璃球（焦散）和漫反射平面。
- **对比指标**：
  - **Path Tracer（无光子映射）**：高噪点，缺失焦散。
  - **Photon Mapping（1M光子）**：平滑间接光照，清晰焦散（需截图对比）。

---

**最终提交**：完整代码（含注释）、可执行文件、测试场景截图及对比分析报告。